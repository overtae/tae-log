---
title: '객체 지향 5대 원칙 - 1'
date: '2024-06-04'
description: '단일 책임 원칙과 의존성 역전 원칙, 클래스 결합도'
tags:
  - '안드로이드'
  - '객체 지향 5대 원칙'
---

> ✨ **오늘 공부한 것**
>
```
- 코틀린 문법 종합반 3주차
- 알고리즘 달리기 경주 풀이
- 개인 과제 깔짝이기
```
>

## 객체 지향 5대 원칙

객체 지향 프로그래밍을 할 때 지켜야 할 5대 원칙을 말한다. 앞 글자만 따서 SOLID 원칙이라고도 하며, 이 원칙을 지키면 유지보수성을 높일 수 있다. 

1. **단일 책임 원칙** (Single Responsibility Principle)
2. **개방 폐쇄 원칙** (Open Closed Principle)
3. **리스코프 치환 원칙** (Liscov Substitution Principle)
4. **인터페이스 분리 원칙** (Interface Sergregation Principle)
5. **의존성 역전 원칙** (Dependency Inversion Principle)

오늘은 이 중에서 단일 책임 원칙과 의존성 역전 원칙에 대해 알아보았다. 

## 단일 책임 원칙 SRP (Single Responsibility Principle)

말 그대로 모든 클래스는 **하나의 책임**만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 한다는 원칙이다.

객체가 담당하는 동작이 많다면, 해당 객체가 변경되었을 때 다른 연관된 객체들도 변경해주어야 한다. 즉, 객체가 담당하는 동작이 많을 수록 다른 객체와의 의존성과 연관성이 커진다. 이를 막기 위한 원칙이 바로 단일 책임 원칙이다. 

### 캡슐화

클래스 안에 **서로 연관있는 속성과 기능들을 하나의 캡슐(capsule)로 만들어 데이터를 외부로부터 보호하는 것**을 말한다. 데이터 보호와 은닉을 위해 사용한다. 

- **데이터 보호:** 외부로부터 클래스에 정의된 속성과 기능 보호
- **데이터 은닉:** 외부에는 필요한 부분만 노출하고, 내부의 동작은 감춘다.

## 의존성 역전 원칙 DIP (Dependency Injectoin Principle)

> 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다. 그 대신 저수준 모듈이 고수준 모듈에서 정의한 **추상 타입에 의존**해야 한다.

의존 관계를 맺을 때 **자신보다 변화하기 쉬운 것에 의존해서는 안되고, 거의 변화가 없는 개념에 의존해야 한다**는 원칙이다. 다르게 말하면, 추상화에 의존해야지, 구체화에 의존하면 안된다는 원칙이다. 

여기서 나오는 고수준 모듈과 저수준 모듈이 도대체 뭘까?

- **고수준 모듈** : 어떤 의미 있는 단일 기능을 제공하는 모듈 
  - interface, 추상 클래스
- **저수준 모듈** : 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현 
  - 메인클래스, 객체

지진이 자주 일어나는 곳에는 높은 건물을 지을 수 없듯이, 변경이 자주 일어나는 메인 클래스에는 의존하면 안되는 것 같다.

## 모듈

자꾸 무슨 모듈.. 모듈.. 이러는데 모듈이 도대체 뭐길래 나오는 것일까. 모듈은 **소프트웨어를 각 기능별로 나눈 소스 단위**를 말한다. 독립적으로 컴파일 가능한 프로그램이나 하나의 함수, 또는 클래스도 모듈이 된다. 

### 모듈화

기능들을 작게 쪼개는 것, 즉 모듈로 나누는 행위를 모듈화라고 한다.

그냥 작게 쪼개는 것이 아니라 **목적에 맞는 기능들로 모듈을 나눠야** 좋은 모듈화라 할 수 있다. 좋은 모듈화가 중요한 이유는 각 모듈이 주어진 기능만을 독립적으로 맡아서 수행해 **재사용성이 높아지고, 유지보수가 용이**해지기 때문이다. 다시 말해 좋은 프로그램이란, 각 모듈의 독립성이 높은 프로그램이라 할 수 있겠다! 

## 결합도와 응집도

모듈의 독립성을 높이려면 어떻게 해야될까? 여기서 나오는 개념이 결합도와 응집도이다. 

- **결합도:** 클래스와 클래스 간의 의존 정도
- **응집도:** 한 모듈 내의 구성 요소들 간의 연관 정도

결합도는 느슨하게, 응집도는 강하게 해줘야 모듈의 독립성이 높아진다. 

### 클래스 결합도

*“의존 정도가 높은 클래스”*, 즉 결합도가 높은 클래스는 어떤 클래스를 의미할까. 뭔가 의존성이 높으면 하나 바꿀 때 다른 것들까지 다 바꿔야 될 것 같은 느낌인데 그게 맞다. 반대로 결합도가 낮은 클래스는 다형성과 개방-폐쇄 원칙을 잘 지킨 클래스를 말한다. 

- **결합도가 높은 클래스:** 클래스 하나의 구조를 변경하게 되면 연관된 클래스 모두 변경해야 한다.
- **결합도가 낮은 클래스:** 다형성을 잘 지킨 클래스, 개방-폐쇄의 원칙을 잘 지킨 클래스

> **⭐ 다형성**
> 
> 
> 어떤 객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 객체지향의 특성
> 
> ex. 오버로딩, 오버라이딩
> 

> **⭐ 개방-폐쇄 원칙 Open-closed principle**
> 
> 
> 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 프로그래밍 원칙
> 

### 결합도 단계

<table>
  <thead>
    <tr>
      <th>세기</th>
      <th>종류</th>
      <th>내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>약함</td>
      <td>자료 결합도<br/>Data Coupling</td>
      <td>모듈간의 인터페이스로 전달되는 파라미터(데이터)를 통해서만 상호 작용이 일어나는 경우<br/>결합도가 제일 낮고 제일 좋은 형태</td>
    </tr>
    <tr>
      <td>↑</td>
      <td>스탬프 결합도<br/>Stamp Coupling</td>
      <td>모듈간의 인터페이스로 배열이나 객체, 자료 구조 등이 전달되는 경우</td>
    </tr>
    <tr>
      <td></td>
      <td>제어 결합도<br/>Control Coupling</td>
      <td>어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하는 제어 요소를 전달하는 경우</td>
    </tr>
    <tr>
      <td></td>
      <td>외부 결합도<br/>External Coupling</td>
      <td>어떤 모듈이 외부에 있는 다른 모듈의 데이터를 참조하는 경우 (데이터, 통신 프로토콜 등)</td>
    </tr>
    <tr>
      <td>↓</td>
      <td>공통 결합도<br/>Common Coupling</td>
      <td>여러 개의 모듈이 하나의 공통 데이터 영역(전역 변수 참조 및 갱신)을 사용하는 경우</td>
    </tr>
    <tr>
      <td>강함</td>
      <td>내용 결합도<br/>Content Coupling</td>
      <td>어떤 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우<br/>결합도가 제일 높고 제일 좋지 않은 형태</td>
    </tr>
  </tbody>
</table>

## 마치며

아직 기능을 구현하는 것도 쉽지 않은데 이런 원칙까지 따지면서 개발하려면 정말 모니터 앞에서 생각만 하는 시간이 늘어날 것 같다. 5가지 원칙 중에서 2가지 원칙만 알아보았는데도 벌써 응용하기 무섭다. 나중에는 뭐 무슨 패턴, 머시기 패턴도 생각해가면서 코드를 작성해야 할텐데 내 머리가 감당할 수 있을까? 그래도 화이팅하는 수 밖에는 없는 거지.. 응.. 아자아자
