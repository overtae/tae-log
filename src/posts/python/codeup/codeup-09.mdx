---
title: '[파이썬 기초 100제] 9강 비트 단위 논리 연산'
date: '2022-01-27'
---

## 문제 59

입력 된 정수를 비트단위로 참/거짓을 바꾼 후 정수로 출력해보자.

예를 들어 1이 입력되었을 때 저장되는 1을 32비트 2진수로 표현하면

00000000 00000000 00000000 00000001 이고,

~1은 11111111 11111111 11111111 11111110 가 되는데 이는 -2를 의미한다.

<Toggle open summary="TIP">

비트단위(bitwise)연산자 ' ~ ' 를 붙이면 된다.
(~ : tilde, 틸드라고 읽는다.)

`~` | bitwise not
`&` | bitwise and
`|` | bitwise or
`^` | bitwise xor
`<<` | bitwise left shift
`>>` | bitwise right shift

</Toggle>

<Toggle open summary="오버플로우란?">

컴퓨터에 저장되는 모든 데이터들은 2진수 형태로 바뀌어 저장된다.

0과 1로만 구성되는 비트단위들로 변환되어 저장되는데,

양의 정수는 2진수 형태로 바뀌어 저장되고,

음의 정수는 "2의 보수 표현"방법으로 저장된다.

예를 들어 파이썬에서는 int형(4바이트(byte), 32비트)으로 선언된 변수에 양의 정수 5를 저장하면

5의 2진수 형태인 101이 32비트로 만들어져

`00000000 00000000 00000000 00000101`

로 저장된다.(공백은 보기 편하도록 임의로 분리)

int 형의 정수 0은

`00000000 00000000 00000000 00000000`

그리고 -1은 0에서 1을 더 빼고 32비트만 표시하는 형태로

`11111111 11111111 11111111 11111111` 로 저장된다.

-2는 -1에서 1을 더 빼면 된다.

`11111111 11111111 11111111 11111110` 로 저장된다.

그래서 int 형으로 선언된 변수에는 최소 `-2147483648` 을 의미하는

`10000000 00000000 00000000 00000000` 부터

최대 `+2147483647` 을 의미하는

`01111111 11111111 11111111 11111111` 로 저장될 수 있는 것이다.

그렇다면 `-2147483648`

`10000000 00000000 00000000 00000000` 에서 1을 더 뺀다면?

`01111111 11111111 11111111 11111111` 이 된다.

즉 `-2147483649` 가 아닌 `+2147483647` 이 되는 것이다.

이러한 것을 "오버플로우(overflow, 넘침)"라고 한다.

이러한 내용을 간단히 표시하면, 정수 n이라고 할 때,

`~n = -n - 1`

`-n = ~n + 1` 과 같은 관계로 표현된다.

</Toggle>

> 풀이

```python
a = int(input())
print(~a)
```

연산자만 알면 문제를 풀 수는 있지만 논리 연산에 대해 다시 공부를 해야할 것 같다..

## 문제 60

입력된 정수 두 개를 비트단위로 and 연산한 후 그 결과를 정수로 출력해보자.

예를 들어 3과 5가 입력되었을 때를 살펴보면

3 : 00000000 00000000 00000000 00000011

5 : 00000000 00000000 00000000 00000101

3 & 5 : 00000000 00000000 00000000 00000001

이 된다.

<Toggle open summary="TIP">

비트단위(bitwise)연산자 &를 사용하면 된다.(and, ampersand, 앰퍼센드라고 읽는다.)
비트단위 and 연산은 두 비트열이 주어졌을 때, 둘 다 1인 부분의 자리만 1로 만들어주는 것과 같다.

이 연산을 이용하면 어떤 비트열의 특정 부분만 모두 0으로도 만들 수 있는데
192.168.0.31   : 11000000.10101000.00000000.00011111
255.255.255.0 : 11111111.11111111.11111111.00000000

두 개의 ip 주소를 & 연산하면
192.168.0.0 : 110000000.10101000.0000000.00000000 을 계산할 수 있다.

실제로 이 계산은 네트워크에 연결되어 있는 두 개의 컴퓨터가 데이터를 주고받기 위해
같은 네트워크에 있는지 아닌지를 판단하는데 사용된다.

이러한 비트단위 연산은 빠른 계산이 필요한 그래픽처리에서
마스크연산(특정 부분을 가리고 출력하는)을 수행하는 데에도 효과적으로 사용된다

</Toggle>

> 풀이

```python
a, b = map(int, input().split())
print(a & b)
```

## Bonus 문제

1개의 정수형 입력이 들어오면 비트 연산을 이용하여 '홀수'와 '짝수'를 판별하여라

<Toggle open summary="TIP">

'짝수'와 '홀수'를 리스트에 담고 짝수일 때는 '짝수'를, 홀수일 때는 '홀수'를 출력하게 한다.
0이 아닌 어떠한 정수일지라도 1과 비트단위 논리곱(&)을 수행하게 되면 1이 되는 특성을 이용한다.

</Toggle>

> 풀이

```python
a = int(input())
print(['짝수', '홀수'][a & 1])
# 짝수의 경우 마지막 숫자가 0이고,
# 홀수의 경우 마지막 숫자가 1임을 이용하면 된다.
```

이해를 잘 한건지는 모르겠지만 배열을 이용한 것 같다.

## 문제 61

입력된 정수 두 개를 비트단위로 or 연산한 후 그 결과를 정수로 출력해보자.

예를 들어 3과 5가 입력되었을 때를 살펴보면

3 : 00000000 00000000 00000000 00000011

5 : 00000000 00000000 00000000 00000101

3 | 5 : 00000000 00000000 00000000 00000111

이 된다.

<Toggle open summary="TIP">

비트단위(bitwise) 연산자 |(or, vertical bar, 버티컬바)를 사용하면 된다.
| 은 파이프(pipe)연산자라고도 불리는 경우가 있다.
비트단위 or 연산은 둘 중 하나라도 1인 자리를 1로 만들어주는 것과 같다.
이러한 비트단위 연산은 빠른 계산이 필요한 그래픽처리에서도 효과적으로 사용된다.

</Toggle>

> 풀이

```python
a, b = map(int, input().split())
print(a | b)
```

## 문제 62

입력된 정수 두 개를 비트단위로 xor 연산한 후 그 결과를 정수로 출력해보자.

예를 들어 3과 5가 입력되었을 때를 살펴보면

3 : 00000000 00000000 00000000 00000011

5 : 00000000 00000000 00000000 00000101

3 ^ 5 : 00000000 00000000 00000000 00000110

이 된다.

<Toggle open summary="TIP">

비트단위(bitwise) 연산자 ^(xor, circumflex/caret, 서컴플렉스/카릿)를 사용하면 된다.
주의 ^은 수학식에서 거듭제곱(power)을 나타내는 기호와 모양은 같지만, 파이썬에서는 전혀 다른 배타적 논리합(xor, 서로 다를 때 1)의 의미를 가진다.

![](/posts/python/codeup/05.png)

이러한 비트단위 연산은 빠른 계산이 필요한 그래픽처리에서도 효과적으로 사용된다.

구체적으로 설명하자면,
두 장의 이미지가 겹쳐졌을 때 색이 서로 다른 부분만 처리할 수 있다.
배경이 되는 그림과 배경 위에서 움직이는 그림이 있을 때,
두 그림에서 차이만 골라내 배경 위에서 움직이는 그림의 색으로 바꿔주면
전체 그림을 구성하는 모든 점들의 색을 다시 계산해 입히지 않고
보다 효과적으로 그림을 처리할 수 있게 되는 것이다.
비행기 슈팅게임 등을 상상해보면 된다.

</Toggle>

> 풀이

```python
a, b = map(int, input().split())
print(a ^ b)
```

## Bonus 문제

문제 직사각형을 만드는 데 필요한 4개의 점 중 3개의 좌표가 주어질 때, 나머지 한 점의 좌표를 구하려고 합니다.

점 3개의 좌표가 들어있는 배열 v가 매개변수로 주어질 때, 직사각형을 만드는 데 필요한 나머지 한 점의 좌표를 return 하도록 solution 함수를 완성해주세요.

단, 직사각형의 각 변은 x축, y축에 평행하며, 반드시 직사각형을 만들 수 있는 경우만 입력으로 주어집니다.

제한사항

- v는 세 점의 좌표가 들어있는 2차원 배열입니다.
- v의 각 원소는 점의 좌표를 나타내며, 좌표는 [x축 좌표, y축 좌표] 순으로 주어집니다.
- 좌표 값은 1 이상 10억 이하의 자연수입니다.
- 직사각형을 만드는 데 필요한 나머지 한 점의 좌표를 [x축 좌표, y축 좌표] 순으로 담아 return 해주세요.

입력 : `[[1,4], [3,4], [3,10]]`

출력 : `[1,10]`

입력 : `[[1,1], [2,2], [1,2]]`

출력 : `[2,1]`

<Toggle open summary="TIP">

나머지 한 점의 좌표는 기존에 좌표에서 없는 좌표이니, 1번만 입력된 좌표들을 찾아서 반환해주면 된다.
XOR 연산을 통해 구현할 수도 있으며, 이 경우 코드의 실행 속도가 굉장히 빠르다.

</Toggle>

> 풀이

```python
v = [[1, 4], [3, 4], [3, 10]]

# 한번씩만 입력된 값을 답 배열에 넣어주면 된다.

# 방법 1 : if-elif
answer = []
for i in range(2):
    if v[0][i] == v[1][i]:
        answer.append(v[2][i])
    elif v[0][i] == v[2][i]:
        answer.append(v[1][i])
    elif v[1][i] == v[2][i]:
        answer.append(v[0][i])

print(answer)

# 방법 2 : XOR
answer = []
answer.append(v[0][0] ^ v[1][0] ^ v[2][0])
answer.append(v[0][1] ^ v[1][1] ^ v[2][1])

print(answer)
```

어떻게 풀어야 될지 감도 못 잡았었다. 수학 공부를 게을리해선 안됐다..

<Callout type="info">

이 게시물은 [우리밋_woorimIT](https://www.youtube.com/watch?v=7sykajCtgCw&list=PLSK4WsJ8JS4dOszA7Zr8paqI81Mv27tNq&index=2)님의 유튜브를 참고하였습니다.

</Callout>
