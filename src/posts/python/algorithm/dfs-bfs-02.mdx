---
title: '[파이썬 알고리즘] DFS/BFS 알고리즘'
date: '2022-07-16'
description: '그래프 탐색 알고리즘인 DFS와 BFS 알고리즘에 대해 알아보자'
tags:
  - 'DFS/BFS'
---

## DFS Depth-First Search

DFS는  **깊이 우선 탐색**이라고도 부르며, **그래프에서 깊은 부분을 우선적으로 탐색**하는 알고리즘이다. 이를 설명하기 전에 그래프의 기본 구조를 알아보도록 하자.

## 그래프

![](/posts/python/algorithm/dfs-bfs/graph-exp.png)

그래프는 **노드**와 **간선**으로 표현되며 이때 노드를 정점이라고도 말한다.

그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말한다.

또한 두 노드가 간선으로 연결되어 있다면 *“두 노드는 인접하다”*라 표현한다.

다른 노드로 이동하기 위해선 간선을 거쳐야 한다.

프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있다.

- 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
- 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식

## 인접 행렬 방식

![](/posts/python/algorithm/dfs-bfs/graph-matrix.png)

옆과 같이 연결된 그래프를 인접 행렬로 표현할 때 파이썬에서는 2차원 리스트를 사용할 수 있다.

연결이 되어 있지 않은 노드끼리는 무한의 비용이라고 작성한다.

실제 코드에서는 무한의 값으로 `999_999_999`이나 `987654321` 등의 값을 채택하는 경우가 많다고 한다.

표로 나타내면 아래와 같고,

|    - |    0 |    1 |    2 |
| ---: | ---: | ---: | ---: |
|    0 |    0 |    7 |    5 |
|    1 |    7 |    0 | 무한 |
|    2 |    5 | 무한 |    0 |

리스트로 나타내면 `[[0, 7, 5], [7, 0, 999999999], [5, 999999999, 0]]` 과 같다.

## 인접 리스트 방식

![](/posts/python/algorithm/dfs-bfs/graph-list.png)

인접 리스트 방식에서는 이미지와 같이 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장한다.

이때 ***연결 리스트***라는 자료구조를 이용해 구현하는데, `C++`이나 `자바`와는 다르게 파이썬은 기본 리스트 자료형이 배열과 연결 리스트의 기능을 **모두 기본으로 제공**해준다.

따라서 파이썬으로 인접 리스트를 이용해 그래프를 표현하고자 할 때에도 **2차원 리스트**를 이용하면 된다.

예제 그래프를 인접 리스트 방식으로 처리할 때 데이터를 초기화한 코드를 확인해보자.

```python showLineNumbers
# 행이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장 (노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장 (노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장 (노드, 거리)
graph[2].append((0, 5))

print(graph)
'''
[[(1, 7), (2, 5)],
[(0, 7)],
[(0, 5)]]
'''
```

## 인접 행렬 방식 vs. 인접 리스트 방식

| -         | 인접 행렬 방식                                     | 인접 리스트 방식                                             |
| --------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 저장 방식 | 모든 관계 저장                                     | 연결된 정보만 저장                                           |
| 메모리    | 노드의 개수가 많을수록 불필요한 메모리 낭비        | 효율적인 메모리 사용                                         |
| 사용      | **특정한 두 노드가 연결**되어 있는지 알고싶은 경우 | 특정한 노드와 연결된 **모든 인접 노드를 순회**해야 하는 경우 |

## DFS 알고리즘의 구체적인 동작

DFS 알고리즘은 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘이다.

**스택 자료구조**를 이용하며 구체적인 동작 과정은 아래와 같다.

1. 탐색 시작 노드를 스택에 삽입 후, 방문 처리
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문 처리. 방문하지 않은 인접 노드가 없다면 스택에서 최상단 노드를 꺼냄.
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복

<Callout type="success" icon="💡">

**방문 처리란?** 스택에 한 번 삽입된 노드가 다시 삽입되지 않게 체크하는 것

</Callout>

일반적으로 인접한 노드중에서 방문하지 않은 노드가 여러 개 있다면 **번호가 낮은 순서**부터 처리한다.

아래 이미지로 DFS를 이용한 탐색 과정을 알아보자.

방문 처리된 노드는 `회색`, 현재 처리하는 스택의 최상단 노드는 `노란색`이다.

![노드의 탐색 순서(스택에 들어간 순서)는 1 → 2 → 7 → 6 → 8 → 3 → 4 → 5 인 걸 알 수 있다.](/posts/python/algorithm/dfs-node.gif)

### 파이썬 예제

DFS는 스택을 이용하는 알고리즘이기에, 파이썬 코드로 구현시 **재귀 함수**를 이용한다면 매우 간결하게 구현이 가능하다.

아래 예제에서도 재귀 함수를 이용한 것을 알 수 있다.

```python showLineNumbers
# DFS 메소드 정의
def dfs(graph, v, visited): # 그래프, 해당 노드 번호, 방문 여부
	# 현재 노드 방문 처리
	visited[v] = True
	print(v, end=' ')
	# 현재 노드와 연결된 다른 노드를 재귀적으로 방문
	for i in graph[v]:
		if not visited[i]:
			dfs(graph, i, visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원)
graph = [
	[], # 0
	[2, 3, 8], # 1
	[1, 7], # 2
	[1, 4, 5], # 3
	[3, 5], # 4
	[3, 4], # 5
	[7], # 6
	[2, 6, 8], # 7
	[1, 7] # 8
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원)
visited = [False] * 9 # 0번 인덱스를 사용하지 않기 위해 8 + 1

# 정의된 dfs 함수 호출
dfs(graph, 1, visited) # 1 2 7 6 8 3 4 5
```

시간 복잡도의 경우 데이터의 개수가 N개일 때 O(N)의 시간이 소요된다.

## BFS Breath First Search

BFS 알고리즘은 **너비 우선 탐색**을 의미하며, **가까운 노드부터 탐색**하는 알고리즘이다.

최대한 멀리 있는 노드를 우선적으로 탐색하는 DFS와 반대라고 할 수 있다.

BFS 구현시 **큐 자료구조**(선입선출 방식)를 이용하는데, 인접한 노드를 큐에 넣는다면 **먼저 들어온 것이 먼저 나가게** 되어 자연스럽게 가까운 노드부터 탐색하기 때문이다.

동작 방식은 아래와 같다.

1. 탐색 시작 노드를 큐에 삽입 후 방문 처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입 + 방문 처리
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복

이번에도 DFS와 같은 그래프로 과정을 알아보자.

DFS와 마찬가지로 숫자가 작은 노드부터 탐색을 진행한다.

![노드의 탐색 순서(스택에 들어간 순서)는 1 → 2 → 3 → 8 → 7 → 4 → 5 → 6 인 걸 알 수 있다.](/posts/python/algorithm/dfs-bfs/bfs-node.gif)

### 파이썬 예제

BFS는 큐 자료구초에 기초하여 파이썬 코드 구현이 간단하다. 

이때, **deque 라이브러리**를 사용하는 것이 좋다는 것을 기억하자. 

DFS와 마찬가지로 O(N)의 시간이 소요되지만…

일반적인 경우에서 실제 수행 시간은 **DFS보다 BFS가 좋은 편**이라고 한다.

왜냐하면 재귀 함수로 DFS를 구현할 경우 컴퓨터 특성상 수행시간이 느려질 수 있기 때문이다.

```python showLineNumbers
from collections import deque

# bfs 메소드 정의
def btf(graph, start, visited):
	# 큐(Queue) 구현을 위한 deque 라이브러리 사용
	queue = deque([start])
	# 현재 노드 방문 처리
	visited[start] = True
	# 큐가 빌 때까지 반복
	while queue:
		# 큐에서 하나의 원소를 뽑아 출력
		v = queue.popleft()
		print(v, end=' ')
		# 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
		for i in graph[v]:
			if not visited[i]:
				queue.append(i)
				visited[i] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원)
graph = [
	[], # 0
	[2, 3, 8], # 1
	[1, 7], # 2
	[1, 4, 5], # 3
	[3, 5], # 4
	[3, 4], # 5
	[7], # 6
	[2, 6, 8], # 7
	[1, 7] # 8
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원)
visited = [False] * 9 # 0번 인덱스를 사용하지 않기 위해 8 + 1

# 정의된 bfs 함수 호출
bfs(graph, 1, visited) # 1 2 3 8 7 4 5 6
```

## 정리

| -         | DFS       | BFS         |
| --------- | --------- | ----------- |
| 동작 원리 | 스택      | 큐          |
| 구현 방법 | 재귀 함수 | 큐 자료구조 |

만약 문제에서 2차원 배열에서의 탐색을 요구한다면 그래프 형태(그림)로 바꿔 생각할 경우 조금 더 쉽게 풀어낼 수 있다.

<Callout type="info">

이 게시물은 한빛미디어의 [이것이 코딩 테스트다](https://book.naver.com/bookdb/book_detail.nhn?bid=16439154) 교재를 참고하였습니다.

</Callout>
